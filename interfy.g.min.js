/** 
 *  Interfy - A Javascript library for robust web front-end routing.
 * 
 *  Github's repo - https://github.com/DenisPower1/interfy
 *  version - 2.1.2
 * 
 *  Created by - Denis Power/ https://github.com/DenisPower1
 *  Global version
 * 
 *  IT WAS REALESED UNDER THE MIT LINCENSE.
*/


!function(){if(null==typeof window&&"object"==typeof global&&"function"==typeof process.on)throw new Error("\n     \n     Interfy is a client-side Javascript routing library,\n     you can only use it in a browser.\n\n     ");if("file:"==window.location.protocol)throw new Error('\n\t\t\n\t\tInterfy can only be used in an "http:" or "https:" protocol.\n\t\t\n\t\t');String.is=function(n){return"[object String]"==t.toString.apply(n,void 0)},String.prototype.has=function(t){if(t instanceof RegExp)return t.test(this)},String.prototype.trimAll=function(){return this.replace(/\s/g,"")};const t=Object.prototype;function n(n){return"[object Function]"==t.toString.call(n)}function e(t){return Object.is(!1,t)}const r={sy(t){const n=new SyntaxError;throw n.message=t,n},err(t){const n=new Error;throw n.message=t,n},wrn:t=>console.warn(t)};function o(t,n){e(f.prototype.production)&&r[t](n)}function a(t,n){if(n){const n=window.location.hash;if(n){""==n.replace(/#/g,"")?window.history.pushState(null,null,`#${t}`):window.history.replaceState(null,null,`#${t}`)}else{"/"==window.location.pathname?window.history.pushState(null,null,`#${t}`):window.history.replaceState(null,null,`#${t}`)}}else{"/"==window.location.pathname?window.history.pushState(null,null,t):window.history.replaceState(null,null,t)}}const s=new Map;s.set("path",void 0);const i=Symbol.for("callBack"),l={[i]:void 0,get url(){return s.get("path")},has:t=>t.has(/\((:?[\s\S]+)\)|\*/g),is(t){const n=this.url,e=t.replace(/\((:?[\s\S]+)\)|\*/g,"[\\s\\S]");return(new RegExp).compile(e).test(n)},getVar:t=>(class{constructor(){}get url(){return s.get("path").trimAll()}static getVar(t){const n=new Array,e=new Array;t.replace(/\/(:?[a-z]+)\/|\/(\d+)/g,(t,e)=>{n.push(t)}),t.replace(/\((:?[a-z]+)\)/g,(t,n)=>{e.push(n)});let r=this.prototype.url.replace(/-|_|\./g,(t,n)=>"_"==t?"d".repeat("down".length):"-"==t?"m".repeat("middle".length):"."==t?"p".repeat("point".length):void 0);for(let t of n)r=r.replace(t,"/");const o=Object.create(null);let a=-1;return r.replace(/(\w+|\d+|[a-z]+)/g,(t,n)=>{a++;let r=n;r.includes("mmmmmm")&&(r=r.replace(/mmmmmm/g,"-")),r.includes("dddd")&&(r=r.replace(/dddd/g,"_")),r.includes("ppppp")&&(r=r.replace(/ppppp/g,".")),o[e[a]]=r}),Object.freeze(o)}}).getVar(t)};function u(){null==new.target&&o("sy","\n       \n       Invoke the [INTERFY CONSTRUCTOR] only\n       with the new keyword.\n\n       \n       ")}function c(t,n){const e=t.next(),r=e.value;e.done||(Object.defineProperty(n,r[0],{get:()=>r[1],configurable:!0}),c(t,n))}Object.preventExtensions(l);const p=Object.create(null),h=new Map;let d=!1;function f(){this.start=function(t=(()=>{})){if(d)return o("wrn","\n            \n            The router was already started.\n\n            "),!1;const e=Object.keys(p).length>0;if(e){d=!0,(new u).createRouter(e=>{let r=!1;n(t)&&t(e.url);for(let[t,n]of Object.entries(p)){if(e.url==t){n(Object.freeze({var:Object.create(null),param:Object.create(null)})),r=!0;break}if(e.has(t)&&e.is(t)){const o=window.location.search;if(r=!0,o){const r=new URLSearchParams(o),a=Object.create(null);c(r.entries(),a),n(Object.freeze({var:e.getVar(t),param:a}))}else{n({var:e.getVar(t),param:Object.create(null)})}}}if(!r&&h.has("notfound")){h.get("notfound")(e.url)}})}e||o("sy","\n          \n          The router can not start, because you did not\n          register any route.\n          \n          ")},this.route=function(t,e){if(d)return o("wrn","\n            \n            You already started the router, so you\n            can not add more routes to it.\n            \n            "),!1;const r=String.is(t);if(arguments.length<2&&o("sy",`\n            \n            The route method accepts two arguments,\n            and you defined: ${arguments.length}.\n\n\n            `),r||o("sy",'\n            \n            The first argument of [ INTERFY INSTANCE ].route \n            must be a string.\n\n            [INTERFY INSTANCE].route("/routename", ()=>{})\n\n            '),n(e)||o("sy","\n            \n            \n            The second argument of [ INTERFY INSTANCE ].route\n            must be a function.\n\n            "),t.startsWith("/")||"*"==t){if("*"==t&&!h.has("notfound"))return h.set("notfound",e),!1;t in p||(p[t]=e)}else o("sy",`\n            \n            Routes must starts with slash(/).\n            it must be "/${t}" instead of "${t}".\n\n            `)}}let w=!1;u.prototype={createRouter(t){if(w)o("err","\n        The router was already created.\n        ");else if(w=!0,n(t)){if(l[i]=t,window.location.hash){const t=window.location.hash.replace(/#/g,"");s.set("path",t),l[i](l)}else s.set("path",window.location.pathname),l[i](l)}else o("sy",`\n     \n    [ INTERFY INSTANCE ].createRouter() accepts only\n     a function as its argument, and you defined\n     "${typeof t}" as its argument.\n    \n    `)}};let g=!1;f.prototype={get version(){return"2.1.0"},get production(){return g},set production(t){if(!this.production){if(e(t))return;if(n=t,!Object.is(!0,n))throw new TypeError(`\n            \n            "${t}" is an invalid value for the\n            [INTERFY INSTANCE].production, property.\n            If you want to turn on the production mode set it to true.\n            \n            `);g=!0,console.log("\n            \n            You are now using Interfy in production mode.\n\n            ")}var n},setPath(t){d||o("err","\n            \n            The router was not started yet, start it firt.\n\n            "),(0,String.is)(t)||o("sy","\n        \n        The pathName in [ INTERFY INSTANCE ].useHash(pathName)\n         must be a string.\n        \n        "),t.startsWith("/")||o("sy",`\n        A pathName must start with a slash(/).\n    \n         You used:\n       \n         [INTERFY INSTANCE ].setPath("${t}")    \n       \n         `),a(t),s.set("path",t),l[i](l)},useHash(t){d||o("err","\n            \n            The router was not started yet, start it firt.\n\n            "),String.is(pathname)||o("sy","\n        \n        The pathName in [ INTERFY INSTANCE ].useHash(pathName)\n         must be a string.\n        \n        "),t.startsWith("/")||o("sy",`\n            A pathName must start with a slash(/).\n        \n             You used:\n           \n              [ INTERFY INSTANCE ].useHash(${t})    \n           \n             `),a(t,!0),s.set("path",t),l[i](l)}},window.onpopstate=function(){const t=this.location.hash,n=this.location.search;if(n){const t=`${this.location.pathname}${n}`;return s.set("path",t),l[i](l),!1}if(t){const n=t.replace(/#/g,"");s.set("path",""==n?"/":n),l[i](l)}else{const t=this.location.pathname;s.set("path",t),l[i](l)}},window.Interfy=f}();
