/** 
 *  Interfy - A Javascript library for robust web front-end routing.
 * 
 *  Github's repo - https://github.com/DenisPower1/Int
 *  version - 1.0.0
 * 
 *  Created by - Denis Power/ https://github.com/DenisPower1
 * 
 *  IT WAS REALESED UNDER THE MIT LINCENSE.
*/


!function(){if("object"==typeof global&&"function"==typeof process.on)throw new Error("\n     \n     Interfy is a client-side Javascript routing library,\n     you can only use it in a browser.\n\n     ");if("file:"==window.location.protocol)throw new Error("\n\t\t\n\t\tInterfy can only be used in an http: or https: protocol.\n\t\t\n\t\t");const t=Object.prototype;function e(e){return"[object String]"==t.toString.call(e)}const n={sy(t){const e=new SyntaxError;throw e.message=t,e},err(t){const e=new Error;throw e.message=t,e},wrn:t=>console.warn(t)};function o(t,e){let o;var a;null==o&&(o=function(){const t=globalThis;return!(!t.Inter||"development"==t.app.status)}()),a=o,Object.is(!1,a)&&n[t](e)}function a(t,e){if(e){const e=window.location.hash;if(e){""==e.replace(/#/g,"")?window.history.pushState(null,null,`#${t}`):window.history.replaceState(null,null,`#${t}`)}else{"/"==window.location.pathname?window.history.pushState(null,null,`#${t}`):window.history.replaceState(null,null,`#${t}`)}}else{"/"==window.location.pathname?window.history.pushState(null,null,t):window.history.replaceState(null,null,t)}}const s=new Map;s.set("path",void 0);const r=Symbol.for("callBack"),l={[r]:void 0,get url(){return s.get("path")},set url(t){return!1},is(t){const e=this.url,n=t.replace(/\(:?([\s\S]+)\)|\*/g,"[\\s\\S]");return(new RegExp).compile(n).test(e)},getVar:t=>(class{constructor(){}get url(){return s.get("path")}static getVar(t){const e=new Array,n=new Array;t.replace(/\/(:?[a-z]+)\/|\/(\d+)/g,(t,n)=>{e.push(t)}),t.replace(/\((:?[a-z]+)\)/g,(t,e)=>{n.push(e)});let o=this.prototype.url.replace(/-|_/g,(t,e)=>"_"==t?"d".repeat("down".length):"-"==t?"m".repeat("middle".length):void 0);for(let t of e)o=o.replace(t,"/");const a=Object.create(null);let s=-1;return o.replace(/(\w+|\d+|[a-z]+)/g,(t,e)=>{s++;let o=e;o.includes("mmmmmm")&&(o=o.replace(/mmmmmm/g,"-")),o.includes("dddd")&&(o=o.replace(/dddd/g,"_")),a[n[s]]=o}),a}}).getVar(t)};function i(){null==new.target&&o("sy","\n       \n       Invoke the [INTERFY CONSTRUCTOR] only\n       with the new keyword.\n\n       \n       ")}Object.preventExtensions(l);let c=!1;i.prototype={createRouter(e){if(c)o("err","\n        The router was already created.\n        ");else if(c=!0,n=e,"[object Function]"!=t.toString.call(n))o("sy",`\n     \n     INTERFY.createRouter() accepts only\n     a function as its argument, and you defined\n     "${typeof e}" as its argument.\n    \n    `);else{if(l[r]=e,window.location.hash){const t=window.location.hash.replace(/#/g,"");s.set("path",t),l[r](l)}else s.set("path",window.location.pathname),l[r](l)}var n},setPath(t){e(t)||o("sy","\n    \n    The pathName in [ INTERFY INSTANCE ].useHash(pathName)\n     must be a string.\n    \n    "),t.startsWith("/")||o("sy",`\n    A pathName must start with a slash(/).\n\n     You used:\n   \n     [INTERFY INSTANCE ].setPath(${t})    \n   \n     `),a(t),s.set("path",t),l[r](l)},useHash(t){e(t)||o("sy","\n    \n    The pathName in [ INTERFY INSTANCE ].useHash(pathName)\n     must be a string.\n    \n    "),t.startsWith("/")||o("sy",`\n        A pathName must start with a slash(/).\n    \n         You used:\n       \n          [ INTERFY INSTANCE ].useHash(${t})    \n       \n         `),a(t,!0),s.set("path",t),l[r](l)}},window.onpopstate=function(){const t=this.location.hash;if(t){const e=t.replace(/#/g,"");s.set("path",""==e?"/":e),l[r](l)}else{const t=this.location.pathname;s.set("path",t),l[r](l)}},"object"==typeof module&&module.exports?exports.Interfy=i:globalThis.Interfy=i}();
