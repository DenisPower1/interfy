/** 
 *  Interfy - A Javascript library for robust web front-end routing.
 * 
 *  Github's repo - https://github.com/DenisPower1/interfy
 *  version - 1.0.1
 * 
 *  Created by - Denis Power/ https://github.com/DenisPower1
 * 
 *  IT WAS REALESED UNDER THE MIT LINCENSE.
*/


!function(){if(null==typeof window&&"object"==typeof global&&"function"==typeof process.on)throw new Error("\n     \n     Interfy is a client-side Javascript routing library,\n     you can only use it in a browser.\n\n     ");if("file:"==window.location.protocol)throw new Error('\n\t\t\n\t\tInterfy can only be used in an "http:" or "https:" protocol.\n\t\t\n\t\t');const t=Object.prototype;function n(n){return"[object String]"==t.toString.call(n)}const e={sy(t){const n=new SyntaxError;throw n.message=t,n},err(t){const n=new Error;throw n.message=t,n},wrn:t=>console.warn(t)};function o(t,n){let o;var a;null==o&&(o=function(){const t=globalThis;return!(!t.Inter||"development"==t.app.status)}()),a=o,Object.is(!1,a)&&e[t](n)}function a(t,n){if(n){const n=window.location.hash;if(n){""==n.replace(/#/g,"")?window.history.pushState(null,null,`#${t}`):window.history.replaceState(null,null,`#${t}`)}else{"/"==window.location.pathname?window.history.pushState(null,null,`#${t}`):window.history.replaceState(null,null,`#${t}`)}}else{"/"==window.location.pathname?window.history.pushState(null,null,t):window.history.replaceState(null,null,t)}}const s=new Map;s.set("path",void 0);const r=Symbol.for("callBack"),l={[r]:void 0,get url(){return s.get("path")},set url(t){return!1},is(t){const n=this.url,e=t.replace(/\(:?([\s\S]+)\)|\*/g,"[\\s\\S]");return(new RegExp).compile(e).test(n)},getVar:t=>(class{constructor(){}get url(){return s.get("path")}static getVar(t){const n=new Array,e=new Array;t.replace(/\/(:?[a-z]+)\/|\/(\d+)/g,(t,e)=>{n.push(t)}),t.replace(/\((:?[a-z]+)\)/g,(t,n)=>{e.push(n)});let o=this.prototype.url.replace(/-|_/g,(t,n)=>"_"==t?"d".repeat("down".length):"-"==t?"m".repeat("middle".length):void 0);for(let t of n)o=o.replace(t,"/");const a=Object.create(null);let s=-1;return o.replace(/(\w+|\d+|[a-z]+)/g,(t,n)=>{s++;let o=n;o.includes("mmmmmm")&&(o=o.replace(/mmmmmm/g,"-")),o.includes("dddd")&&(o=o.replace(/dddd/g,"_")),a[e[s]]=o}),a}}).getVar(t)};function i(){null==new.target&&o("sy","\n       \n       Invoke the [INTERFY CONSTRUCTOR] only\n       with the new keyword.\n\n       \n       ")}Object.preventExtensions(l);let c=!1;i.prototype={createRouter(n){if(c)o("err","\n        The router was already created.\n        ");else if(c=!0,e=n,"[object Function]"!=t.toString.call(e))o("sy",`\n     \n    [ INTERFY INSTANCE ].createRouter() accepts only\n     a function as its argument, and you defined\n     "${typeof n}" as its argument.\n    \n    `);else{if(l[r]=n,window.location.hash){const t=window.location.hash.replace(/#/g,"");s.set("path",t),l[r](l)}else s.set("path",window.location.pathname),l[r](l)}var e},setPath(t){n(t)||o("sy","\n    \n    The pathName in [ INTERFY INSTANCE ].useHash(pathName)\n     must be a string.\n    \n    "),t.startsWith("/")||o("sy",`\n    A pathName must start with a slash(/).\n\n     You used:\n   \n     [INTERFY INSTANCE ].setPath("${t}")    \n   \n     `),a(t),s.set("path",t),l[r](l)},useHash(t){n(t)||o("sy","\n    \n    The pathName in [ INTERFY INSTANCE ].useHash(pathName)\n     must be a string.\n    \n    "),t.startsWith("/")||o("sy",`\n        A pathName must start with a slash(/).\n    \n         You used:\n       \n          [ INTERFY INSTANCE ].useHash(${t})    \n       \n         `),a(t,!0),s.set("path",t),l[r](l)}},window.onpopstate=function(){const t=this.location.hash;if(t){const n=t.replace(/#/g,"");s.set("path",""==n?"/":n),l[r](l)}else{const t=this.location.pathname;s.set("path",t),l[r](l)}},globalThis.Interfy=i}();
